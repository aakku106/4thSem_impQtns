# Theory of Computation - Strategic Study Plan (Target: 35+ Marks)

## üìä Overall Strategy

- **Full Marks**: 60 (2 Long √ó 10 + 8 Short √ó 5)
- **Pass Marks**: 24
- **Your Target**: 35+ marks
- **Strategy**: Focus on high-frequency topics with guaranteed scoring potential

---

## üéØ Question Pattern Analysis (7 Sets Analyzed)

### Section A - Long Questions (Attempt 2 out of 3) - 20 Marks Total

| Topic/Chapter                           | Frequency | Years Appeared                          | Priority       | Expected Marks |
| --------------------------------------- | --------- | --------------------------------------- | -------------- | -------------- |
| **NFA/DFA Conversion & Construction**   | 6/7       | 2076, 2078, 2079, 2080, 2080_new, Model | ‚≠ê‚≠ê‚≠ê HIGHEST | 10 marks       |
| **Turing Machine Construction**         | 6/7       | 2076, 2078, 2080, 2080_new, 2081, Model | ‚≠ê‚≠ê‚≠ê HIGHEST | 10 marks       |
| **CFG to CNF Conversion**               | 4/7       | 2078, 2079, 2080, 2080_new              | ‚≠ê‚≠ê‚≠ê HIGH    | 10 marks       |
| **PDA Construction & Conversion**       | 4/7       | 2076, 2080_new, 2081, Model             | ‚≠ê‚≠ê‚≠ê HIGH    | 10 marks       |
| **Regular Expression to FA**            | 2/7       | 2076, 2079                              | ‚≠ê‚≠ê MEDIUM    | 10 marks       |
| **Pumping Lemma for Regular Languages** | 1/7       | 2079                                    | ‚≠ê‚≠ê MEDIUM    | 10 marks       |
| **DFA Minimization**                    | 1/7       | 2078, 2081                              | ‚≠ê‚≠ê MEDIUM    | 10 marks       |

### Section B - Short Questions (Attempt 8 out of 12) - 40 Marks Total

| Topic/Chapter                                     | Frequency | Priority       | Expected Marks |
| ------------------------------------------------- | --------- | -------------- | -------------- |
| **Regular Expression Construction**               | 7/7       | ‚≠ê‚≠ê‚≠ê MUST DO | 5 marks        |
| **DFA/NFA Construction**                          | 6/7       | ‚≠ê‚≠ê‚≠ê MUST DO | 5 marks        |
| **PDA Construction**                              | 5/7       | ‚≠ê‚≠ê‚≠ê HIGH    | 5 marks        |
| **Pumping Lemma Applications**                    | 5/7       | ‚≠ê‚≠ê‚≠ê HIGH    | 5 marks        |
| **CNF/GNF Definitions & Examples**                | 4/7       | ‚≠ê‚≠ê‚≠ê HIGH    | 5 marks        |
| **Basic Definitions** (String, Alphabet, Closure) | 4/7       | ‚≠ê‚≠ê‚≠ê HIGH    | 5 marks        |
| **CFG Construction & Derivations**                | 4/7       | ‚≠ê‚≠ê‚≠ê HIGH    | 5 marks        |
| **Complexity & Intractability**                   | 4/7       | ‚≠ê‚≠ê‚≠ê HIGH    | 5 marks        |
| **TM Variations**                                 | 4/7       | ‚≠ê‚≠ê MEDIUM    | 5 marks        |
| **PDA to CFG / CFG to PDA**                       | 3/7       | ‚≠ê‚≠ê MEDIUM    | 5 marks        |
| **Undecidable Problems**                          | 3/7       | ‚≠ê‚≠ê MEDIUM    | 5 marks        |
| **Moore/Mealy Machines**                          | 2/7       | ‚≠ê‚≠ê MEDIUM    | 5 marks        |
| **Chomsky Hierarchy**                             | 2/7       | ‚≠ê LOW         | 5 marks        |
| **Regular Grammar to FA**                         | 2/7       | ‚≠ê LOW         | 5 marks        |

---

## üéì Unit-Wise Importance & Expected Marks

| Unit                             | Topics                                     | Importance | Expected Questions   | Target Marks |
| -------------------------------- | ------------------------------------------ | ---------- | -------------------- | ------------ |
| **Unit 2: Finite Automata**      | DFA, NFA, Œµ-NFA, Conversions, Moore/Mealy  | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | 1 Long + 2-3 Short   | 20-25 marks  |
| **Unit 6: Turing Machine**       | TM Construction, Variations, Encoding, UTM | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | 1 Long + 1-2 Short   | 15-20 marks  |
| **Unit 4: Context Free Grammar** | CFG, CNF, GNF, Parse Trees, Derivations    | ‚≠ê‚≠ê‚≠ê‚≠ê   | 1 Long + 2-3 Short   | 15-20 marks  |
| **Unit 3: Regular Expressions**  | RE Construction, RE to FA, Pumping Lemma   | ‚≠ê‚≠ê‚≠ê‚≠ê   | 0-1 Long + 2-3 Short | 10-15 marks  |
| **Unit 5: Push Down Automata**   | PDA Construction, PDA-CFG Conversions      | ‚≠ê‚≠ê‚≠ê‚≠ê   | 0-1 Long + 2 Short   | 10-15 marks  |
| **Unit 7: Undecidability**       | Complexity Classes, PCP, Halting Problem   | ‚≠ê‚≠ê‚≠ê     | 0 Long + 1-2 Short   | 5-10 marks   |
| **Unit 1: Basic Foundations**    | Definitions, Closures, String Operations   | ‚≠ê‚≠ê‚≠ê     | 0 Long + 1 Short     | 5 marks      |

---

## üìö Detailed Topic Breakdown & Study Roadmap

### üî• PRIORITY 1: Must-Study Topics (Target: 25-30 Marks)

#### 1. DFA/NFA Construction & Conversion (Unit 2) - **6/7 papers, Long Question**

**Why This Topic?**

- Appears in almost every exam as a **10-mark problem**
- Algorithmic, step-by-step process = **full marks if practiced**
- Most fundamental topic in TOC

**What to Master:**

**A. Formal Definitions**

**DFA (Deterministic Finite Automaton):**

```
DFA = (Q, Œ£, Œ¥, q0, F)

where:
- Q = Finite set of states
- Œ£ = Finite input alphabet
- Œ¥: Q √ó Œ£ ‚Üí Q (Transition function)
- q0 ‚àà Q (Initial state)
- F ‚äÜ Q (Set of final/accepting states)
```

**NFA (Non-deterministic Finite Automaton):**

```
NFA = (Q, Œ£, Œ¥, q0, F)

where:
- Œ¥: Q √ó Œ£ ‚Üí 2^Q (Power set - can go to multiple states)
```

**Œµ-NFA (NFA with Epsilon Transitions):**

```
Œµ-NFA = (Q, Œ£, Œ¥, q0, F)

where:
- Œ¥: Q √ó (Œ£ ‚à™ {Œµ}) ‚Üí 2^Q (Can transition on Œµ without input)
```

**B. Key Concepts**

1. **Extended Transition Function (Œ¥\*)**

   - Processes entire strings instead of single symbols
   - For DFA: Œ¥\*(q, wa) = Œ¥(Œ¥\*(q, w), a)
   - Base: Œ¥\*(q, Œµ) = q

2. **Œµ-Closure**
   - Œµ-closure(q) = Set of all states reachable from q using only Œµ-transitions
   - Example: If Œµ-closure(q0) = {q0, q1, q2}, then from q0 we can reach q1 and q2 without consuming input

**C. NFA to DFA Conversion (Subset Construction)**

**Algorithm:**

```
1. Start with Œµ-closure of initial state as new start state
2. For each new state (which is a set of NFA states):
   For each input symbol a:
     - Find all states reachable on 'a'
     - Take Œµ-closure of those states
     - Create new DFA state (if not exists)
3. Mark states as final if they contain any NFA final state
4. Repeat until no new states are created
```

**Example Problem (Common Pattern):**
"Construct NFA for strings ending with '01', then convert to DFA"

**NFA Solution:**

```
States: {q0, q1, q2}
Initial: q0
Final: {q2}

Transitions:
q0 --0--> q0, q1
q0 --1--> q0
q1 --1--> q2
```

**DFA After Conversion:**
Use subset construction to get deterministic states.

**D. Common Construction Patterns**

1. **Even/Odd Number of Symbols**

   - Example: Even 0's and Even 1's
   - Use 4 states representing (even-0, even-1), (even-0, odd-1), (odd-0, even-1), (odd-0, odd-1)

2. **Substring Detection**

   - Example: Contains substring "01"
   - Track progress: no match ‚Üí saw 0 ‚Üí saw 01 (final)

3. **Ending Pattern**
   - Example: Ends with "00"
   - Last 2 symbols: track with 4 states (Œµ, 0, 1, 00)

**Past Question Examples:**

- 2076: NFA to DFA conversion, strings ending with 01
- 2078: NFA to DFA with given transition table
- 2079: Prove NFA = DFA equivalence
- 2080: NFA to DFA with given diagram
- 2080_new: NFA for substring 01 ending with 1
- Model: DFA for even 0's and even 1's

**Expected Score:** 9-10/10 with clear diagrams and tables

---

#### 2. Turing Machine Construction (Unit 6) - **6/7 papers, Long Question**

**Why This Topic?**

- Appears as **10-mark long question** almost every year
- Design-based, shows understanding of computation
- Instantaneous Description (ID) sequence is easy scoring

**What to Master:**

**A. Formal Definition**

```
TM = (Q, Œ£, Œì, Œ¥, q0, B, F)

where:
- Q = Finite set of states
- Œ£ = Input alphabet
- Œì = Tape alphabet (Œ£ ‚äÜ Œì)
- Œ¥: Q √ó Œì ‚Üí Q √ó Œì √ó {L, R} (Transition function)
- q0 = Initial state
- B ‚àà Œì = Blank symbol
- F ‚äÜ Q = Final/accepting states
```

**B. Instantaneous Description (ID)**

```
Format: Œ± q Œ≤

where:
- Œ± = symbols to left of head
- q = current state
- Œ≤ = symbol at head + symbols to right

Example: 001 q2 1011
- Tape has 0011011
- Head is at 4th position (reading 1)
- Machine is in state q2
```

**C. Common TM Construction Patterns**

**1. Language: L = {0‚Åø1‚Åø | n ‚â• 1}**

```
Strategy:
1. Mark first 0 as X, move right
2. Find first 1, mark as Y, move left
3. Find next unmarked 0, mark as X
4. Repeat until all matched
5. Check only Y's remain

Transition Example:
Œ¥(q0, 0) = (q1, X, R)  // Mark 0 as X
Œ¥(q1, 0) = (q1, 0, R)  // Skip 0's
Œ¥(q1, 1) = (q2, Y, L)  // Mark 1 as Y
Œ¥(q2, 0) = (q2, 0, L)  // Go back
Œ¥(q2, X) = (q0, X, R)  // Next iteration
```

**2. Language: L = {wcw·¥ø | w ‚àà (0,1)\*}**

```
Strategy:
1. Mark first symbol, remember it
2. Find 'c', move right
3. Go to end, match with remembered symbol
4. Repeat until all matched before 'c'

States needed:
- Remember 0 or 1
- Different states for left and right of 'c'
```

**3. Computing Function: f(x) = 2x**

```
Input: n 1's
Output: 2n 1's

Strategy:
1. For each 1, write two 1's on right
2. Mark processed 1's
3. Clean up markers
```

**D. TM Variations**

1. **Multi-tape TM**

   - Multiple tapes, each with own head
   - Can simulate single-tape TM (but faster)
   - Œ¥: Q √ó Œì·µè ‚Üí Q √ó Œì·µè √ó {L,R,S}·µè

2. **Multi-track TM**

   - Single tape divided into tracks
   - Read/write entire column at once
   - Useful for marking/remembering

3. **Non-deterministic TM**

   - Multiple possible moves
   - Accepts if ANY path accepts
   - Œ¥: Q √ó Œì ‚Üí 2^(Q √ó Œì √ó {L,R})

4. **Semi-infinite Tape TM**
   - Tape only on right (no left movement from start)
   - Can simulate regular TM

**E. Universal Turing Machine (UTM)**

**Encoding:**

```
Encode states: q0‚Üí1, q1‚Üí11, q2‚Üí111, ...
Encode symbols: 0‚Üí1, 1‚Üí11, a‚Üí111, ...
Encode direction: L‚Üí1, R‚Üí11

Encode transition Œ¥(qi, aj) = (qk, al, Dm):
111...1 0 11...1 0 111...1 0 11...1 0 1...1
  (i)      (j)      (k)      (l)     (m)

Separate transitions with 00
Entire TM code separated with 000
```

**F. Showing Acceptance with ID Sequence**

**Example: Accept "0110" by palindrome checker**

```
ID Sequence:
q0 0110  ‚Üí  X q1 110  ‚Üí  X1 q1 10  ‚Üí  X11 q1 0  ‚Üí
X1 q2 10  ‚Üí  X q2 110  ‚Üí  q2 X110  ‚Üí  X q3 110  ‚Üí
XX q1 10  ‚Üí  XXY q4 0  ‚Üí  XX q5 Y0  ‚Üí  XXY q5 0  ‚Üí
XXYY q6 Œµ  ‚Üí  Accept (all symbols matched)
```

**Past Question Examples:**

- 2076: TM for {wcw·¥ø}, show acceptance of "0110"
- 2078: TM for odd length strings, with encoding
- 2080: TM for {a01a, a10a, a0101a}, show acceptance
- 2080_new: TM for f(n) = 0
- 2081: TM for f(x) = 2x, input 11 ‚Üí output 1111
- Model: TM for L = {(n)n}, balanced parentheses

**Expected Score:** 8-10/10 with transition table/diagram + ID sequence

---

#### 3. Regular Expression Construction (Unit 3) - **7/7 papers, Short Question**

**Why This Topic?**

- Appears in **EVERY exam** as short question
- Easy 5 marks if patterns are memorized
- Quick to solve (5-7 minutes)

**What to Master:**

**Common Patterns Over {0, 1}:**

| Pattern Description              | Regular Expression                                  | Explanation                           |
| -------------------------------- | --------------------------------------------------- | ------------------------------------- |
| Strings ending with 0            | (0+1)\*0                                            | Any symbols, then must end with 0     |
| Strings starting with 1          | 1(0+1)\*                                            | Must start with 1, then anything      |
| Even number of 0's               | 1\*(01\*01\*)\*                                     | Pair up 0's with 1's in between       |
| Odd number of 1's                | 0\*10\*(10\*10\*)\*                                 | One 1, then pairs of 1's              |
| Contains substring "01"          | (0+1)\*01(0+1)\*                                    | Anything, then 01, then anything      |
| No consecutive 1's               | (0+10)\*(Œµ+1)                                       | Always insert 0 between 1's           |
| Length is multiple of 3          | ((0+1)(0+1)(0+1))\*                                 | Groups of 3 symbols                   |
| 2nd symbol from right is 1       | (0+1)\*1(0+1)                                       | ...1X pattern                         |
| Starts with 00 or 11             | (00+11)(0+1)\*                                      | Either 00 or 11, then anything        |
| Ends with 10 or 01               | (0+1)\*(10+01)                                      | Anything, then 10 or 01               |
| At least 3 symbols               | (0+1)(0+1)(0+1)(0+1)\*                              | 3 mandatory, rest optional            |
| Exactly 2 a's and at least 2 b's | b\*ab\*abb\* + b\*abb\*ab\* + abb\*ab\* + ab\*abb\* | All arrangements of 2 a's with ‚â•2 b's |
| 3rd symbol is a, 5th is b        | (0+1)(0+1)a(0+1)b(0+1)\*                            | Fix positions 3 and 5                 |

**Advanced Patterns:**

1. **Even a's, each a followed by at least one b**

   - Strategy: Every 'a' must have 'b+' after it, repeat even times
   - Answer: (b\*ab+b\*ab+)\*

2. **Not ending with 0**

   - Strategy: Must end with 1 or be empty
   - Answer: (0+1)\*1 + Œµ

3. **Substring bab or abb**
   - Strategy: Anything, then either pattern, then anything
   - Answer: (a+b)\*(bab+abb)(a+b)\*

**Conversion Examples:**

**Regular Expression to Œµ-NFA (Thompson's Construction):**

- Base: Œµ ‚Üí single Œµ-transition
- Base: a ‚Üí single transition labeled 'a'
- Union: r1+r2 ‚Üí parallel paths with Œµ
- Concatenation: r1r2 ‚Üí series connection with Œµ
- Kleene: r\* ‚Üí loop back with Œµ

**Past Question Examples:**

- 2076: 2nd from right is 1; starts 00/11, ends 10/01
- 2078: Substring bab or abb; 3rd is a, 5th is b
- 2079: (0+1)\*10(1+0); 1\*0(0+1)\*1
- 2080: Exactly 2 a's, ‚â•2 b's; Even a's each followed by ‚â•1 b
- 2080_new: Even numbers length 4, start 2, end 8; Odd start, even end
- 2081: Not ending with 0; Length ‚â•3 ends with 00
- Model: Even numbers starting with 2 ending with 8

**Expected Score:** 4-5/5 marks (easiest topic!)

---

### üî• PRIORITY 2: High-Probability Topics (Target: 15-20 Marks)

#### 4. CFG to CNF Conversion (Unit 4) - **4/7 papers, Long Question**

**Why This Topic?**

- Frequent **10-mark long question**
- Mechanical algorithm = guaranteed marks
- Shows up in 4 out of 7 papers

**What to Master:**

**A. Definitions**

**Context Free Grammar:**

```
CFG = (V, T, P, S)

where:
- V = Variables (non-terminals)
- T = Terminals
- P = Production rules
- S = Start symbol
```

**Chomsky Normal Form (CNF):**

- All productions are either:
  - A ‚Üí BC (two non-terminals)
  - A ‚Üí a (single terminal)
  - S ‚Üí Œµ (only if Œµ ‚àà L)

**Greibach Normal Form (GNF):**

- All productions are:
  - A ‚Üí aŒ± (terminal followed by zero or more non-terminals)

**B. Conversion Algorithm to CNF**

**Step 1: Remove Œµ-productions**

```
Find nullable variables (those that can derive Œµ)
For each production with nullable variable, create version with/without it
Remove A ‚Üí Œµ productions
```

**Step 2: Remove Unit Productions (A ‚Üí B)**

```
Find all unit pairs (A, B) where A ‚áí* B via unit productions only
Replace A ‚Üí B with A ‚Üí Œ± for all B ‚Üí Œ±
```

**Step 3: Remove Useless Symbols**

```
Remove symbols that don't derive any terminal string (non-generating)
Remove symbols not reachable from start symbol (unreachable)
```

**Step 4: Convert to CNF**

```
For productions like A ‚Üí B1B2...Bn (n > 2):
  Create new variables: A ‚Üí B1C1, C1 ‚Üí B2C2, ... Cn-2 ‚Üí Bn-1Bn

For terminals in mixed productions (A ‚Üí aB or A ‚Üí Ba):
  Create new variable: D ‚Üí a, then replace 'a' with D
```

**C. Worked Example**

**Given Grammar:**

```
S ‚Üí ASB | Œµ
A ‚Üí aA | a
B ‚Üí bB | b
```

**Step 1: Remove Œµ (S is nullable)**

```
S ‚Üí ASB | AB | AS | SB | A | B
A ‚Üí aA | a
B ‚Üí bB | b
```

**Step 2: Remove Unit Productions**

```
S derives A: S ‚Üí aA | a
S derives B: S ‚Üí bB | b

Final:
S ‚Üí ASB | AB | AS | SB | aA | a | bB | b
A ‚Üí aA | a
B ‚Üí bB | b
```

**Step 3: No useless symbols**

**Step 4: Convert to CNF**

```
For S ‚Üí ASB: Create C1, so S ‚Üí AC1, C1 ‚Üí SB
For terminals: Create T_a ‚Üí a, T_b ‚Üí b

Final CNF:
S ‚Üí AC1 | AB | AS | SB | T_aA | T_a | T_bB | T_b
C1 ‚Üí SB
A ‚Üí T_aA | T_a
B ‚Üí T_bB | T_b
T_a ‚Üí a
T_b ‚Üí b
```

**D. Left Recursion Removal** (Often asked)

**Direct Left Recursion:**

```
A ‚Üí AŒ± | Œ≤

Convert to:
A ‚Üí Œ≤A'
A' ‚Üí Œ±A' | Œµ
```

**Example:**

```
E ‚Üí E+T | T

Becomes:
E ‚Üí TE'
E' ‚Üí +TE' | Œµ
```

**Past Question Examples:**

- 2078: S ‚Üí abSb | a | aAb; A ‚Üí bS | aAAb | Œµ
- 2079: Remove left recursion from expression grammar, then CNF
- 2080: CFG to CNF conversion with example
- 2080_new: Grammar to CNF (given in question)

**Expected Score:** 8-10/10 with clear steps

---

#### 5. PDA Construction (Unit 5) - **5/7 papers, Short Question**

**Why This Topic?**

- Frequent **5-mark short question**
- Standard patterns are easy to memorize
- Shows understanding of stack-based computation

**What to Master:**

**A. Formal Definition**

```
PDA = (Q, Œ£, Œì, Œ¥, q0, Z0, F)

where:
- Q = States
- Œ£ = Input alphabet
- Œì = Stack alphabet
- Œ¥: Q √ó (Œ£ ‚à™ {Œµ}) √ó Œì ‚Üí 2^(Q √ó Œì*)
- q0 = Initial state
- Z0 = Initial stack symbol
- F = Final states
```

**B. Transition Notation**

```
Œ¥(q, a, X) = {(p, Œ±)}

Meaning:
- In state q
- Reading input 'a' (or Œµ)
- Top of stack is X
- Go to state p
- Replace X with Œ± (Œ± can be Œµ for pop, or XY for push Y)
```

**C. Common PDA Patterns**

**1. L = {0‚Åø1‚Åø | n ‚â• 0}** (Equal 0's and 1's)

```
States: {q0, q1, q2}
Stack: {Z0, X}

Transitions:
Œ¥(q0, Œµ, Z0) = {(q1, Z0)}       // Start
Œ¥(q1, 0, Z0) = {(q1, XZ0)}      // First 0, push X
Œ¥(q1, 0, X) = {(q1, XX)}        // More 0's, push X
Œ¥(q1, 1, X) = {(q2, Œµ)}         // See 1, pop X
Œ¥(q2, 1, X) = {(q2, Œµ)}         // More 1's, pop X
Œ¥(q2, Œµ, Z0) = {(accept)}       // All matched
```

**2. L = {ww·¥ø | w ‚àà Œ£\*}** (Palindromes)

```
Strategy:
- Push first half onto stack
- Guess middle (use Œµ-transition)
- Pop and match second half

Example for {0,1}:
Œ¥(q0, 0, Z) = {(q0, 0Z)}        // Push 0
Œ¥(q0, 1, Z) = {(q0, 1Z)}        // Push 1
Œ¥(q0, Œµ, Z) = {(q1, Z)}         // Guess middle
Œ¥(q1, 0, 0) = {(q1, Œµ)}         // Match 0
Œ¥(q1, 1, 1) = {(q1, Œµ)}         // Match 1
```

**3. L = {wcw·¥ø | w ‚àà {0,1}\*}** (Marked palindrome)

```
Œ¥(q0, 0, Z) = {(q0, 0Z)}        // Push 0's and 1's
Œ¥(q0, 1, Z) = {(q0, 1Z)}
Œ¥(q0, c, Z) = {(q1, Z)}         // See 'c', switch to matching
Œ¥(q1, 0, 0) = {(q1, Œµ)}         // Pop and match
Œ¥(q1, 1, 1) = {(q1, Œµ)}
Œ¥(q1, Œµ, Z0) = {(accept)}
```

**D. Showing Acceptance with IDs**

**Format: (state, remaining_input, stack)**

**Example: Accept "0101" by L = {0‚Åø1‚Åø | n=2}**

```
(q0, 0101, Z0)
‚ä¢ (q1, 0101, Z0)
‚ä¢ (q1, 101, XZ0)       // Read 0, push X
‚ä¢ (q1, 01, XXZ0)       // Read 0, push X
‚ä¢ (q2, 1, XZ0)         // Read 1, pop X
‚ä¢ (q2, Œµ, Z0)          // Read 1, pop X
‚ä¢ Accept               // Empty input, only Z0
```

**E. Acceptance Methods**

1. **Acceptance by Final State**

   - PDA halts in state q ‚àà F
   - Stack can have anything

2. **Acceptance by Empty Stack**
   - Stack becomes empty
   - State doesn't matter

**Conversion:**

- Final State ‚Üí Empty Stack: Add transitions to pop all symbols
- Empty Stack ‚Üí Final State: Add new bottom marker and final state

**Past Question Examples:**

- 2076: PDA for equal 0's and 1's, show ID for "0101"
- 2078: PDA for L = {a‚Åøb‚Åø | n > 0}
- 2080: PDA for L = {x‚Åøy‚Åøxy | n‚â•0}, show acceptance "xyxy"
- 2080_new: PDA for equal a's and b's (a‚Åøb‚Åø), show "aabb" and "aab"
- Model: PDA for {wcw·¥ø}, show "011C110" and "10C10"

**Expected Score:** 4-5/5 marks

---

#### 6. Pumping Lemma Applications (Unit 3) - **5/7 papers, Short Question**

**Why This Topic?**

- Appears as **5-mark proof question**
- Standard proof structure = easy marks
- Only 3-4 common patterns

**What to Master:**

**A. Pumping Lemma for Regular Languages**

**Statement:**

```
If L is regular, then ‚àÉ pumping length p such that:
‚àÄ string s ‚àà L where |s| ‚â• p, we can write s = xyz with:

1. |xy| ‚â§ p
2. |y| > 0
3. ‚àÄ i ‚â• 0, xy‚Å±z ‚àà L
```

**How to Use (Proof by Contradiction):**

```
1. Assume L is regular
2. Let p be the pumping length
3. Choose a string s ‚àà L where |s| ‚â• p
4. By PL, s = xyz with conditions 1-3
5. Find a value of i such that xy‚Å±z ‚àâ L
6. Contradiction! L is not regular
```

**B. Common Non-Regular Language Proofs**

**1. L = {0‚Åø1‚Åø | n ‚â• 0}**

```
Proof:
- Assume L is regular with pumping length p
- Choose s = 0^p 1^p (clearly in L, |s| = 2p ‚â• p)
- By PL, s = xyz where |xy| ‚â§ p and |y| > 0
- Since |xy| ‚â§ p, both x and y consist only of 0's
- So y = 0^k for some k > 0
- Consider xy¬≤z = 0^(p+k) 1^p
- This has more 0's than 1's, so NOT in L
- Contradiction! L is not regular
```

**2. L = {a‚Åø | n is prime}**

```
Proof:
- Assume L is regular with pumping length p
- Choose s = a^q where q is prime and q ‚â• p
- By PL, s = xyz where |xy| ‚â§ p, |y| > 0
- Let |y| = k > 0
- Consider xy^(q+1)z = a^(q + kq) = a^(q(k+1))
- This is NOT prime (composite: multiple of q and k+1)
- Contradiction! L is not regular
```

**3. L = {a‚Å±b ≤c·µè | j = i+k}**

```
Proof:
- Choose s = a^p b^(2p) c^p
- By PL, |xy| ‚â§ p means y is all a's
- Pumping changes a's but not b's or c's
- Violates j = i+k constraint
- Contradiction! Not regular
```

**C. Pumping Lemma for CFLs**

**Statement:**

```
If L is context-free, then ‚àÉ pumping length p such that:
‚àÄ string s ‚àà L where |s| ‚â• p, we can write s = uvxyz with:

1. |vxy| ‚â§ p
2. |vy| > 0
3. ‚àÄ i ‚â• 0, uv‚Å±xy‚Å±z ‚àà L
```

**Common Non-CFL Proof:**

**L = {a‚Åøb‚Åøc‚Åø | n ‚â• 0}**

```
Proof:
- Assume L is CFL with pumping length p
- Choose s = a^p b^p c^p
- By PL for CFL, s = uvxyz where |vxy| ‚â§ p, |vy| > 0
- Case 1: vxy contains only one type of symbol
  - Pumping changes count of only that symbol
  - Violates equal count requirement
- Case 2: vxy spans two types (e.g., a's and b's)
  - Pumping can create order like abab...
  - Not in L (must be a*b*c*)
- Both cases lead to contradiction!
- L is not CFL
```

**Past Question Examples:**

- 2076: L = {0·µê1·µê | m‚â•1}
- 2078: L = {a‚Åø | n is prime}
- 2079: State and prove Pumping Lemma
- 2080: L = {a‚Å±b ≤c·µè | j=i+k}
- 2080_new: L = {a‚Åøb‚Åøc‚Åø | n‚â•0} (for CFL)
- Model: L = {0‚Åø1‚Åø | n>0}

**Expected Score:** 4-5/5 marks with clear proof

---

### üî• PRIORITY 3: Backup Topics (Target: 10-15 Marks)

#### 7. CNF/GNF Definitions (Unit 4) - **4/7 papers, Short Question**

**Quick Answer Format:**

**Chomsky Normal Form (CNF):**

- Definition: All productions are A ‚Üí BC or A ‚Üí a
- Example:
  ```
  S ‚Üí AB
  A ‚Üí a
  B ‚Üí b
  ```

**Greibach Normal Form (GNF):**

- Definition: All productions are A ‚Üí aŒ± (terminal + non-terminals)
- Example:
  ```
  S ‚Üí aAB
  A ‚Üí a
  B ‚Üí bB | b
  ```

**Expected Score:** 3-5/5

---

#### 8. Basic Definitions (Unit 1) - **4/7 papers, Short Question**

**Quick Definitions:**

1. **Alphabet (Œ£):** Finite set of symbols

   - Example: Œ£ = {0, 1}

2. **String:** Finite sequence of symbols from alphabet

   - Example: 0110 is a string over {0, 1}

3. **Empty String (Œµ):** String with no symbols, length = 0

4. **Substring:** Contiguous part of a string

   - "01" is substring of "0110"

5. **Prefix:** Beginning portion of a string

   - "011" is prefix of "0110"

6. **Suffix:** Ending portion of a string

   - "10" is suffix of "0110"

7. **Concatenation:** Joining two strings

   - "01" + "10" = "0110"

8. **Kleene Closure (Œ£\*):** Set of all possible strings (including Œµ)

   - {0,1}\* = {Œµ, 0, 1, 00, 01, 10, 11, 000, ...}

9. **Positive Closure (Œ£‚Å∫):** Set of all strings except Œµ

   - {0,1}‚Å∫ = {0, 1, 00, 01, 10, 11, 000, ...}

10. **Language:** Set of strings over alphabet

    - L = {0‚Åø1‚Åø | n‚â•0} is a language

11. **Empty Language (‚àÖ):** Language with no strings
    - Different from {Œµ} which contains empty string

**Example Computations:**

- Œ£ = {ab}, Œ£\* = {Œµ, ab, abab, ababab, ...}
- Œ£¬≤ = {abab} (strings of length 2)

**Expected Score:** 4-5/5

---

#### 9. CFG Construction & Derivations (Unit 4) - **4/7 papers, Short Question**

**Common Patterns:**

**1. Palindromes over {a, b}**

```
S ‚Üí aSa | bSb | a | b | Œµ
```

**2. Equal number of a's and b's**

```
S ‚Üí aSbS | bSaS | Œµ
```

**3. Strings starting and ending with same symbol**

```
S ‚Üí aSa | bSb | a | b | aXa | bXb
X ‚Üí aX | bX | Œµ
```

**4. Balanced Parentheses**

```
S ‚Üí SS | (S) | Œµ
```

**Derivation Types:**

**Leftmost Derivation:** Always expand leftmost non-terminal first

```
Example: S ‚Üí AB, A ‚Üí a, B ‚Üí b
S ‚áí AB ‚áí aB ‚áí ab  (leftmost)
```

**Rightmost Derivation:** Always expand rightmost non-terminal first

```
S ‚áí AB ‚áí Ab ‚áí ab  (rightmost)
```

**Parse Tree:** Graphical representation of derivation

- Root = Start symbol
- Leaves = Terminal symbols
- Internal nodes = Non-terminals

**Expected Score:** 4-5/5

---

#### 10. Complexity & Intractability (Unit 7) - **4/7 papers, Short Question**

**Key Concepts:**

**A. Time Complexity of TM**

- T(n) = Maximum number of steps on input of size n

**B. Space Complexity of TM**

- S(n) = Maximum tape cells used on input of size n

**C. Big-O, Omega, Theta Notation**

1. **Big-O (Upper Bound):** f(n) = O(g(n))

   - f(n) grows no faster than g(n)
   - Example: 3n¬≤ + 5n = O(n¬≤)

2. **Big-Œ© (Lower Bound):** f(n) = Œ©(g(n))

   - f(n) grows at least as fast as g(n)
   - Example: 3n¬≤ + 5n = Œ©(n¬≤)

3. **Big-Œò (Tight Bound):** f(n) = Œò(g(n))
   - f(n) grows exactly like g(n)
   - Example: 3n¬≤ + 5n = Œò(n¬≤)

**D. Complexity Classes**

1. **Class P (Polynomial Time)**

   - Problems solvable in O(n·µè) time by deterministic TM
   - Example: Sorting, searching, shortest path

2. **Class NP (Non-deterministic Polynomial)**

   - Problems verifiable in polynomial time
   - Solution can be checked quickly
   - Example: SAT, Hamiltonian path, graph coloring

3. **NP-Complete**

   - Hardest problems in NP
   - If any NP-complete problem is in P, then P = NP
   - Example: SAT, 3-SAT, vertex cover

4. **NP-Hard**
   - At least as hard as NP-complete
   - May not be in NP
   - Example: Halting problem

**E. Tractable vs Intractable**

- **Tractable:** Solvable in polynomial time (P problems)
- **Intractable:** Requires super-polynomial time (exponential, etc.)

**SAT Problem:**

- Boolean Satisfiability Problem
- Given: Boolean formula
- Question: Is there assignment making it TRUE?
- Status: NP-complete (Cook's Theorem)

**Expected Score:** 4-5/5

---

#### 11. Undecidable Problems (Unit 7) - **3/7 papers, Short Question**

**A. Halting Problem**

**Definition:**

- Given: TM M and input w
- Question: Does M halt on input w?

**Proof of Undecidability (Contradiction):**

```
1. Assume H(M, w) decides halting problem
   - H(M, w) = accept if M halts on w
   - H(M, w) = reject if M loops on w

2. Construct D(M):
   - If H(M, M) = accept, then loop forever
   - If H(M, M) = reject, then halt

3. What does D do on input D?
   - If D(D) halts, then H(D, D) = accept
     ‚Üí D should loop (by definition)
     ‚Üí Contradiction!
   - If D(D) loops, then H(D, D) = reject
     ‚Üí D should halt
     ‚Üí Contradiction!

4. Both cases are contradictions
   ‚Üí H cannot exist
   ‚Üí Halting problem is undecidable
```

**B. Post's Correspondence Problem (PCP)**

**Definition:**
Given two lists of strings: A = {w1, w2, ..., wn} and B = {v1, v2, ..., vn}

Find sequence i1, i2, ..., ik such that:
wi1 wi2 ... wik = vi1 vi2 ... vik

**Example:**

```
A = {ab, a, ba}
B = {aba, ab, a}

Solution: i1=1, i2=2, i3=3
A: ab + a + ba = ababa
B: aba + ab + a = ababa
Match! ‚úì
```

**Status:** PCP is undecidable (cannot determine if solution exists in general)

**C. Other Undecidable Problems**

1. Does TM M accept any input?
2. Does TM M accept all inputs?
3. Are two TMs equivalent?
4. Is language of TM regular/context-free?

**Expected Score:** 3-5/5

---

#### 12. Moore vs Mealy Machines (Unit 2) - **2/7 papers, Short Question**

**Comparison:**

| Aspect            | Moore Machine               | Mealy Machine                         |
| ----------------- | --------------------------- | ------------------------------------- |
| Output depends on | Current state only          | Current state + Input                 |
| Output produced   | On entering state           | During transition                     |
| Transition format | (state, input) ‚Üí next state | (state, input) ‚Üí (next state, output) |
| Output function   | Œª: Q ‚Üí O                    | Œª: Q √ó Œ£ ‚Üí O                          |
| Diagram           | Output inside state circles | Output on transition arrows           |

**Example: Moore Machine (Output A if ends with aa, B if ends with bb)**

```
States with outputs:
q0 [Output: -]
q1 (saw a) [Output: -]
q2 (saw aa) [Output: A]
q3 (saw b) [Output: -]
q4 (saw bb) [Output: B]
```

**Example: Mealy Machine (Same problem)**

```
Transitions with outputs:
q0 --a/-- ‚Üí q1
q1 --a/A ‚Üí q1  (output A)
q1 --b/-- ‚Üí q2
q0 --b/-- ‚Üí q2
q2 --b/B ‚Üí q2  (output B)
q2 --a/-- ‚Üí q1
```

**Expected Score:** 3-5/5

---

## üìù Exam Strategy: Picking Questions for 35+ Marks

### **Section A: Pick 2 Long Questions (20 Marks)**

**Recommended Picks:**

1. **DFA/NFA Construction or Conversion** ‚Üí 9-10 marks

   - Always appears, mechanical, full marks guaranteed

2. **Turing Machine Construction** ‚Üí 8-10 marks
   - Design + ID sequence, high scoring

**Backup:** 3. **CFG to CNF** ‚Üí 8-10 marks

- Algorithmic, step-by-step

**Avoid if possible:** Pumping Lemma (as long question), DFA Minimization (complex)

### **Section B: Pick 8 Short Questions (40 Marks)**

**First Priority (Pick if they appear):**

1. Regular Expression Construction ‚Üí 5 marks
2. DFA/NFA Construction (simple) ‚Üí 5 marks
3. PDA Construction ‚Üí 4-5 marks
4. Pumping Lemma Proof ‚Üí 4-5 marks

**Second Priority (Pick 4 more):** 5. CNF/GNF Definitions ‚Üí 4-5 marks 6. Basic Definitions (Alphabet, Closure) ‚Üí 5 marks 7. CFG & Derivations ‚Üí 4-5 marks 8. Complexity & Big-O ‚Üí 4-5 marks

**Backups:** 9. TM Variations ‚Üí 3-5 marks 10. Undecidable Problems ‚Üí 3-5 marks

**Total Expected:** 2√ó10 (long) + 8√ó5 (short) = **20 + 36-40 = 56-60 marks potential**
**Realistic Score:** 18 (long) + 32-35 (short) = **50-53 marks** (well above 35+ target)

---

## üóìÔ∏è Study Roadmap (10-Day Plan)

### **Day 1-2: Master DFA/NFA**

- Practice 5-6 DFA constructions (even/odd, substring, ending pattern)
- Practice 3-4 NFA to DFA conversions
- Learn subset construction algorithm cold

### **Day 3-4: Master Turing Machines**

- Practice 4-5 TM constructions (0‚Åø1‚Åø, palindrome, functions)
- Practice writing ID sequences
- Understand encoding for UTM

### **Day 5: Master Regular Expressions**

- Memorize 10-12 common patterns
- Practice RE to Œµ-NFA conversion (Thompson's)
- Quick 30-minute session (highest ROI!)

### **Day 6-7: CFG & CNF**

- Practice CNF conversion algorithm (4-5 problems)
- Practice CFG constructions (palindromes, equal counts)
- Learn left recursion removal

### **Day 8: PDA & Pumping Lemma**

- Practice 3-4 PDA constructions
- Memorize 3 standard Pumping Lemma proofs
- Practice ID sequences for PDA

### **Day 9: Short Question Topics**

- Definitions (1 hour)
- Complexity & Intractability (1 hour)
- Undecidable problems (1 hour)
- Moore/Mealy machines (1 hour)

### **Day 10: Revision & Mock Test**

- Solve 1 full question paper in 3 hours
- Time yourself: 30 min per long, 10-12 min per short
- Review mistakes

---

## üìê Key Formulas & Notations

### Automata Definitions

```
DFA: (Q, Œ£, Œ¥, q0, F)
- Œ¥: Q √ó Œ£ ‚Üí Q

NFA: (Q, Œ£, Œ¥, q0, F)
- Œ¥: Q √ó Œ£ ‚Üí 2^Q

Œµ-NFA: (Q, Œ£, Œ¥, q0, F)
- Œ¥: Q √ó (Œ£ ‚à™ {Œµ}) ‚Üí 2^Q

PDA: (Q, Œ£, Œì, Œ¥, q0, Z0, F)
- Œ¥: Q √ó (Œ£ ‚à™ {Œµ}) √ó Œì ‚Üí 2^(Q √ó Œì*)

TM: (Q, Œ£, Œì, Œ¥, q0, B, F)
- Œ¥: Q √ó Œì ‚Üí Q √ó Œì √ó {L, R}
```

### Regular Expression Operators

```
Union: r1 + r2
Concatenation: r1 ¬∑ r2 or r1r2
Kleene Star: r*
Positive Closure: r+ = rr*
```

### Complexity Notation

```
O(f(n)): Upper bound
Œ©(f(n)): Lower bound
Œò(f(n)): Tight bound
```

### Pumping Lemma (Regular)

```
s = xyz where:
1. |xy| ‚â§ p
2. |y| > 0
3. ‚àÄi ‚â• 0, xy^i z ‚àà L
```

### Pumping Lemma (CFL)

```
s = uvxyz where:
1. |vxy| ‚â§ p
2. |vy| > 0
3. ‚àÄi ‚â• 0, uv^i xy^i z ‚àà L
```

---

## ‚úÖ Final Checklist (Before Exam)

### Long Questions (Must Know)

- [ ] DFA construction (3 patterns: even/odd, substring, ending)
- [ ] NFA to DFA conversion (subset construction)
- [ ] TM construction (0‚Åø1‚Åø, palindrome, function)
- [ ] TM ID sequence (can show 5-6 steps)
- [ ] CFG to CNF (all 4 steps)
- [ ] Left recursion removal

### Short Questions (Must Know)

- [ ] Regular expressions (12 common patterns memorized)
- [ ] PDA construction (equal count, palindrome)
- [ ] Pumping Lemma proof (3 standard proofs)
- [ ] CNF/GNF definitions + examples
- [ ] Basic definitions (alphabet, closure, string)
- [ ] CFG construction (palindrome, balanced)
- [ ] Complexity classes (P, NP, NP-Complete)
- [ ] Big-O/Omega/Theta definitions

### Design Skills

- [ ] Can draw state diagrams clearly
- [ ] Can write transition tables accurately
- [ ] Can show ID sequences step-by-step
- [ ] Can construct parse trees

### Writing Speed

- [ ] Can solve DFA/NFA in 20 minutes (long)
- [ ] Can solve TM in 25 minutes (long)
- [ ] Can write RE in 5 minutes (short)
- [ ] Can do Pumping Lemma proof in 10 minutes

---

## üéØ Final Score Projection

**Conservative Estimate:**

- Long Q1 (DFA/NFA): 8/10
- Long Q2 (TM): 8/10
- Short Q1-4 (RE, DFA, PDA, Pumping): 4√ó4 = 16/20
- Short Q5-8 (CNF, Definitions, CFG, Complexity): 4√ó4 = 16/20

**Total: 8+8+16+16 = 48 marks** ‚úÖ (Well above 35 target)

**Optimistic Estimate:**

- Long: 9+9 = 18/20
- Short: 8√ó4.5 = 36/40

**Total: 18+36 = 54 marks** ‚úÖ (Excellent score)

---

## üí° Pro Tips

1. **DFA/NFA Construction:** Always draw state diagram FIRST, then write transition table. Diagram helps visualize.

2. **Turing Machines:** Use descriptive state names (q_match0, q_match1) instead of q0, q1. Makes design clearer.

3. **Regular Expressions:** Break complex patterns into parts. Example: "even 0's" = (1\*01\*01\*)\*

4. **CNF Conversion:** Do step-by-step, don't skip. Examiners give marks for each step.

5. **Pumping Lemma:** Always state "Assume L is regular" and "Contradiction" explicitly. These words matter.

6. **ID Sequences:** Write minimum 5-6 steps. Show the transition clearly with ‚ä¢ symbol.

7. **Time management:**

   - Long questions: 25-30 minutes each (total 50-60 min)
   - Short questions: 8-12 minutes each (total 64-96 min)
   - Revision: 20 minutes

8. **Diagrams score big:** For automata, always draw transition diagrams. They're worth 2-3 marks even if transitions are wrong.

9. **Practice with timer:** TOC has many constructions. Speed comes only with timed practice.

10. **Memorize patterns:** Don't try to derive everything in exam. Memorize standard patterns (RE, PDA, TM).

---

**Good luck! Focus on DFA/NFA and Turing Machines for long questions, and Regular Expressions for guaranteed short marks! üöÄ**
